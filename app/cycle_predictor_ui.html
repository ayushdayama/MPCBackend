<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cycle Predictor UI</title>
    <style>
        body { font-family: Arial, sans-serif; background: #f7f7f7; margin: 0; padding: 0; }
        .container { max-width: 500px; margin: 40px auto; background: #fff; border-radius: 8px; box-shadow: 0 2px 8px #0001; padding: 32px; }
        h1 { text-align: center; color: #4a90e2; }
        button { background: #4a90e2; color: #fff; border: none; padding: 12px 24px; border-radius: 4px; font-size: 16px; cursor: pointer; margin-top: 12px; }
        button:disabled { background: #b0c4de; }
        .result, .feedback-result { margin-top: 20px; font-size: 18px; color: #333; }
        textarea, input[type="date"], input[type="month"] { width: 100%; border-radius: 4px; border: 1px solid #ccc; padding: 8px; font-size: 15px; margin-top: 10px; }
        label { font-weight: bold; display: block; margin-top: 24px; }
        .nav { text-align: center; margin-bottom: 24px; }
        .nav button { margin: 0 8px; }
        .view { display: none; }
        .view.active { display: block; }
    </style>
</head>
<body>
    <div class="container">
        <h1>Cycle Predictor</h1>
        <div class="nav">
            <button id="mainViewBtn">Prediction</button>
            <button id="feedbackViewBtn">Feedback</button>
            <button id="trainViewBtn">Train Model</button>
        </div>
        <div id="mainView" class="view active">
            <button id="predictBtn">Get Next Cycle Date</button>
            <div class="result" id="result"></div>
            <label for="monthPicker">Predict cycles for month:</label>
            <input type="month" id="monthPicker" />
            <button id="predictMonthBtn">Predict for Month</button>
            <div class="result" id="monthResult"></div>
        </div>
        <div id="feedbackView" class="view">
            <label for="predicted_date">Predicted Date:</label>
            <input type="date" id="predicted_date" />
            <label for="actual_date">Actual Date:</label>
            <input type="date" id="actual_date" />
            <label for="feedback">Comment (optional):</label>
            <textarea id="feedback" placeholder="Enter your feedback here..."></textarea>
            <button id="feedbackBtn">Submit Feedback</button>
            <div class="feedback-result" id="feedbackResult"></div>
        </div>
        <div id="trainView" class="view">
            <button id="trainBtn">Train Model</button>
            <div class="result" id="trainResult"></div>
        </div>
    </div>
    <script>
        // Use relative path for API base (works on Railway and local)
        const apiBase = '';
        // Navigation
        function showView(viewId) {
            document.querySelectorAll('.view').forEach(v => v.classList.remove('active'));
            document.getElementById(viewId).classList.add('active');
        }
        document.getElementById('mainViewBtn').onclick = () => showView('mainView');
        document.getElementById('feedbackViewBtn').onclick = () => showView('feedbackView');
        document.getElementById('trainViewBtn').onclick = () => showView('trainView');

        // Predict next cycle
        document.getElementById('predictBtn').onclick = async function() {
            const resultDiv = document.getElementById('result');
            resultDiv.textContent = 'Loading...';
            try {
                // Fetch last recorded date
                const cycleRes = await fetch(`${apiBase}/cycle_data`);
                const cycleData = await cycleRes.json();
                const allDates = cycleData.dates;
                const lastDate = allDates.length ? allDates[allDates.length-1] : null;
                // Fetch next prediction (top 3)
                const res = await fetch(`${apiBase}/predict`);
                if (!res.ok) throw new Error('API error');
                const data = await res.json();
                let html = '';
                if (lastDate) {
                    html += `<b>Last recorded cycle date:</b> ${lastDate}<br>`;
                }
                if (data.top_dates && data.top_dates.length > 0) {
                    html += `<b>Most confident prediction:</b> ${data.top_dates[0]}<br>`;
                    if (data.top_dates.length > 1) {
                        html += `<span style='color:orange'><b>Other possible dates (less likely):</b><br>${data.top_dates.slice(1).join('<br>')}</span>`;
                    }
                } else {
                    html += 'No prediction available.';
                }
                resultDiv.innerHTML = html;
            } catch (e) {
                resultDiv.textContent = 'Failed to fetch prediction.';
            }
        };

        // Predict for selected month
        document.getElementById('predictMonthBtn').onclick = async function() {
            const monthResult = document.getElementById('monthResult');
            const monthVal = document.getElementById('monthPicker').value;
            if (!monthVal) {
                monthResult.textContent = 'Please select a month.';
                return;
            }
            monthResult.textContent = 'Loading...';
            try {
                // Fetch last recorded date
                const cycleRes = await fetch(`${apiBase}/cycle_data`);
                const cycleData = await cycleRes.json();
                const allDates = cycleData.dates;
                const lastDate = allDates.length ? allDates[allDates.length-1] : null;
                // Fetch next prediction (top 3)
                const res = await fetch(`${apiBase}/predict`);
                if (!res.ok) throw new Error('API error');
                const data = await res.json();
                // Simulate future cycles using top 3 intervals
                let html = '';
                if (lastDate) {
                    html += `<b>Last recorded cycle date:</b> ${lastDate}<br>`;
                }
                if (data.top_dates && data.top_dates.length > 0) {
                    // Use the intervals between last date and each top prediction
                    const lastDateObj = new Date(lastDate);
                    const intervals = data.top_dates.map(d => (new Date(d) - lastDateObj) / (1000*60*60*24));
                    let predictions = [[], [], []];
                    for (let i = 0; i < 24; ++i) {
                        for (let j = 0; j < intervals.length; ++j) {
                            let next = new Date(lastDateObj.getTime() + intervals[j]*24*60*60*1000*(i+1));
                            const y = next.getFullYear();
                            const m = (next.getMonth()+1).toString().padStart(2,'0');
                            if (`${y}-${m}` === monthVal) {
                                predictions[j].push(next.toISOString().slice(0,10));
                            }
                        }
                    }
                    // Sort each prediction group
                    predictions = predictions.map(group => group.sort());
                    if (predictions[0].length) {
                        html += `<b>Most confident prediction(s) for ${monthVal}:</b><br>${predictions[0].join('<br>')}<br>`;
                    }
                    if (predictions[1].length || predictions[2].length) {
                        html += `<span style='color:orange'><b>Other possible dates (less likely):</b><br>${[...predictions[1], ...predictions[2]].sort().join('<br>')}</span>`;
                    }
                } else {
                    html += 'No prediction available.';
                }
                monthResult.innerHTML = html;
            } catch (e) {
                monthResult.textContent = 'Failed to predict for month.';
            }
        };

        // Feedback
        document.getElementById('feedbackBtn').onclick = async function() {
            const predicted_date = document.getElementById('predicted_date').value;
            const actual_date = document.getElementById('actual_date').value;
            const comment = document.getElementById('feedback').value.trim();
            const feedbackResult = document.getElementById('feedbackResult');
            if (!predicted_date || !actual_date) {
                feedbackResult.textContent = 'Please enter both predicted and actual dates.';
                return;
            }
            feedbackResult.textContent = 'Submitting...';
            try {
                const res = await fetch(`${apiBase}/feedback`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ predicted_date, actual_date, comment })
                });
                if (!res.ok) throw new Error('API error');
                const data = await res.json();
                feedbackResult.textContent = data.message;
                document.getElementById('feedback').value = '';
                document.getElementById('predicted_date').value = '';
                document.getElementById('actual_date').value = '';
            } catch (e) {
                feedbackResult.textContent = 'Failed to submit feedback.';
            }
        };
        // Train
        document.getElementById('trainBtn').onclick = async function() {
            const trainResult = document.getElementById('trainResult');
            trainResult.textContent = 'Training model...';
            try {
                const res = await fetch(`${apiBase}/train`, {
                    method: 'POST'
                });
                if (!res.ok) throw new Error('API error');
                const data = await res.json();
                trainResult.textContent = data.message;
            } catch (e) {
                trainResult.textContent = 'Failed to train model.';
            }
        };
    </script>
</body>
</html>
